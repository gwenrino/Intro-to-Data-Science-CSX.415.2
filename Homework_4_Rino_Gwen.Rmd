---
title: "COMPSCIX 415.2 Homework 3"
author: "Gwen Rino"
date: "2/20/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r load_packages, warning=FALSE, message=FALSE}
library(tidyverse)
library(nycflights13)
```

**R for Data Science Exercise 5.6.7**

2. 
```{r, eval=FALSE}
not_cancelled <- flights %>% filter(!is.na(dep_delay), !is.na(arr_delay))

# An approach that gives the same output as not_cancelled %>% count(dest)
not_cancelled %>% group_by(dest) %>% summarize(n = n()) 

# An approach that gives the same output as not_cancelled %>% count(tailnum, wt = distance)
not_cancelled %>% group_by(tailnum) %>% summarize(n = sum(distance))
```

4. It's difficult to discern a pattern for the number of cancelled flights per day. There is a spike in cancelled flights on days 39 and 40, which suggests there may have been a winter storm.

The second visualization suggests that as the average delay increases for a particular day, so does the number of cancelled flights. This makes intuitive sense!

```{r}
# Number of flights cancelled per day of year
flights %>% filter(is.na(dep_delay), is.na(arr_delay)) %>%
  group_by(month, day) %>% count(day)
# Create vector of conversions of time_hour to day of the year
doy <- as.numeric(strftime(flights$time_hour, format = "%j"))
# Mutate flights to add day_of_year variable
flights.1 <- flights %>%
  mutate(day_of_year = doy) 
# Visualize number of cancelled flights per day
cancelled <- flights.1 %>% filter(is.na(dep_delay), is.na(arr_delay)) %>%
  add_count(month, day)
ggplot(cancelled, aes(x = day_of_year, y = n)) + geom_point(alpha = .6)
# Compare proportion of cancelled flights to average delay for each day
summary <- flights.1 %>% group_by(day_of_year) %>%
  summarize(
    num_cancelled = sum(is.na(dep_delay) & is.na(arr_delay)),
    prop_cancelled = mean(is.na(dep_delay) & is.na(arr_delay)),
    ave_delay = mean(dep_delay, na.rm = TRUE)
  )
# Visualize comparison of proportion of cancelled flights to average delay
ggplot(summary, aes(x = ave_delay, y = prop_cancelled)) + geom_point(alpha = .6)
```

5. The first dataframe (below) shows that F9 is the carrier with the greatest mean dep_delay. However, the second dataframe shows that F9 only flew to one destination (DEN), and only 685 flights. Other carriers made different numbers of flights to different numbers of airports (for example, EV flew thousands of flights to 61 different airports). When I look at the third dataframe, sorted by mean_delay and grouped by carrier and destination, I can see that EV is the carrier that is most routinely late.

```{r}
flights %>% group_by(carrier) %>% 
  summarize(mean_delay = mean(dep_delay, na.rm = TRUE)) %>%
  arrange(mean_delay)

flights %>% group_by(carrier, dest) %>% summarize(n())

flights %>% group_by(dest, carrier) %>% 
  summarize(
    mean_delay = mean(dep_delay, na.rm = TRUE),
    n = n()) %>%
  arrange(mean_delay)
```

6. The sort argument to count() sorts the output in descending order of n. It provides a quick way to see not just the max and min, but the several highest and lowest occurring counts. This could give you ideas for next steps in an analysis (e.g. what do the several highest count or several lowest count groups have in common?).

**R for Data Science Exercise 10.5**

1. You can tell an object is a tibble by printing it (it returns the classification "a tibble"), or by using class(). When printed in the console, tibbles are easier to read than data frames because they do not wrap columns around and print them below. They also include the type of data in each column, which data frames do not. (Tibbles and data frames seem to be equally easy to read in RMarkdown.)

2. The data frame subsetting `df$x` extracts the data in column `xyz`, whereas the tibble subsetting `tb$x` returns an error (it distinguishes `x` from `xyz`).
```{r}
df <- data.frame(abc = 1, xyz = "a")
tb <- tibble(abc = 1, xyz = "a")
df$x
tb$x
```

The data frame subsetting `df[, "xyz"]` returns the contents of column `xyz` as a factor, whereas the tibble subsetting `tb[, "xyz"]` returns it as a tibble.
```{r}
df[, "xyz"]
tb[, "xyz"]
```

The data frame subsetting `df[, c("abc", "xyz")]` returns a data frame, while the tibble subsetting `tb[, c("abc", "xyz")]` returns a tibble. The data types of column `xyz` in the two outcomes are different (factor for the data frame, character for the tibble).
```{r}
df[, c("abc", "xyz")]
tb[, c("abc", "xyz")]
```

The data frame defaults could be frustrating because a typo in subsetting a column name wouldn't be caught so you could easily make a mistake without knowing it. Also, it could be frustrating that the type of object being returned changes. When you're working with a tibble, the results will always also be a tibble, so you don't have to consider the class of object.

3. You can extract a reference variable named as an object from a tibble as coded here:
```{r, eval = FALSE}
vari <- "carrier"
flights[vari]
```

6. The option `n_extra` controls how many additional column names are printed at the footer of a tibble.

**R for Data Science Exercise 12.3.3**

2. Why does this code fail?

table4a %>% 
  gather(1999, 2000, key = "year", value = "cases")
#> Error in combine_vars(vars, ind_list): Position must be between 0 and n

3. Why does spreading this tibble fail? How could you add a new column to fix the problem?

people <- tribble(
  ~name,             ~key,    ~value,
  #-----------------|--------|------
  "Phillip Woods",   "age",       45,
  "Phillip Woods",   "height",   186,
  "Phillip Woods",   "age",       50,
  "Jessica Cordero", "age",       37,
  "Jessica Cordero", "height",   156
)

4. Tidy the simple tibble below. Do you need to spread or gather it? What are the variables?

preg <- tribble(
  ~pregnant, ~male, ~female,
  "yes",     NA,    10,
  "no",      20,    12
)

**R for Data Science Exercise 12.4.3**

1. What do the extra and fill arguments do in separate()? Experiment with the various options for the following two toy datasets.

tibble(x = c("a,b,c", "d,e,f,g", "h,i,j")) %>% 
  separate(x, c("one", "two", "three"))

tibble(x = c("a,b,c", "d,e", "f,g,i")) %>% 
  separate(x, c("one", "two", "three"))

2. Both unite() and separate() have a remove argument. What does it do? Why would you set it to FALSE?

**Final Question**

```{r}
baby_names <- read_delim("baby_names.txt", delim = "|") # Load baby_names.txt
glimpse(baby_names)

saveRDS(baby_names, file = "baby_names.rds") # Export baby_names as rds file

baby_names_rds <- readRDS(file = "baby_names.rds") # Reload baby_names.rds
glimpse(baby_names_rds)
```

